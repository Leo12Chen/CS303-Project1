A simple algorithm for handling requests: all requests users make are stored.
The elevator prioritizes the requests that are on the way where itâ€™s going, but also based on a first come first served principle.

Write a simulation function that calculates the waiting time for users.
 A user pushes either the up or down button to request the elevator.
 Once the elevator arrives, the user gets in and specifies his/her destination floor. 
 Meanwhile, other users outside or inside the elevator make requests as well.

1. How many types of data structure will we have and how will they be implemented.
2. What are we trying to do? (create a queue for elevator? How do we determine how the elevator moves?)
3. how many classes are we using? (Elevator class, passenger class?, queue class?, list?)

We need to create a UML and Diagram and do a Big-O of each functions.

/////////////////////////////////////////////////////////////////////////////////////////////////
#algorithm by leo
struct Request{
 tendency (up or down)
 theFloorRequestAt
 theFloorRequestTo
 }
 
 listOfStop;
 uprequestlist;
 downrequestlist;
 FirstRequest;
 
 if FirstRequest.tendency = up
  uprequestlist insert FirstRequest;
 if FirstRequest.tendency = down
  downrequestlist insert FirstRequest;
 tendency = FirstRequest.tendency;
 
 insert(data){
  if list.empty == true{
  list.head = data;
  }
  else
   for (i== list.begin(), list.end(),i++){
    if i.data< data < i->next.data
     insert data here;
   } 
 }
 
 
 while tendency == up{
      for (i = uprequestlist.begin(),uprequestlist.end(),i++){
        listOfStop.insert i.theFloorRequestAt;
        listOfStop.insert i.theFloorRequestTo;
        }
      if OutsideButton.tendency == up && currentfloor<OutsideButton.theFloorRequestAt{
        listOfStop insert OutsideButton.theFloorRequestAt;
        listOfStop insert OutsideButton.theFloorRequestTo;
        }
      if OutsideButton.tendency == up && OutsideButton.theFloorRequestAt<currentfloor{
         uprequestlist insert OutsideButton;
         }
      if OutsideButton.tendency == down && OutsideButton.theFloorRequestAt{
         downrequestlist insert OutsideButton;
      }
    if currentfloor reach the element in listOfStop{
    listOfStop.delete iterater
    }
    if listOfStop.empty == true{
    tendency = down
    }
    
 while tendency == down{
    for (i = downrequestlist.begin(),downrequestlist.end(),i++)
     listOfStop.insert i.theFloorRequestAt;
     listOfStop.insert i.theFloorRequestTo;
    if OutsideButton.tendency == down && currentfloor>OutsideButton.theFloorRequestAt{
        listOfStop insert OutsideButton.theFloorRequestAt;
        listOfStop insert OutsideButton.theFloorRequestTo;
        }
      if OutsideButton.tendency == down && OutsideButton.theFloorRequestAt>currentfloor{
         downrequestlist insert OutsideButton;
         }
      if OutsideButton.tendency == up && OutsideButton.theFloorRequestAt{
         uprequestlist insert OutsideButton;
      }
    if currentfloor reach the element in listOfStop{
    listOfStop.delete iterater
    }
    if listOfStop.empty == true{
    tendency = up
    } 
 }
 #end here
/////////////////////////////////////////////////////////////////////////////////////////////////////    
        
return 0;



