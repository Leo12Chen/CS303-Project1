A simple algorithm for handling requests: all requests users make are stored.
The elevator prioritizes the requests that are on the way where itâ€™s going, but also based on a first come first served principle.

Write a simulation function that calculates the waiting time for users.
 A user pushes either the up or down button to request the elevator.
 Once the elevator arrives, the user gets in and specifies his/her destination floor. 
 Meanwhile, other users outside or inside the elevator make requests as well.

1. How many types of data structure will we have and how will they be implemented.
2. What are we trying to do? (create a queue for elevator? How do we determine how the elevator moves?)
3. how many classes are we using? (Elevator class, passenger class?, queue class?, list?)

We need to create a UML and Diagram and do a Big-O of each functions.

/////////////////////////////////////////////////////////////////////////////////////////////////
#algorithm by leo
#For single elevator (Havent finished yet)
struct Request{
 tendency (up or down)
 theFloorRequestAt
 theFloorRequestTo
 }
 
 listOfStop;
 uprequestlist;
 downrequestlist;
 FirstRequest;
 
 if FirstRequest.tendency = up
  uprequestlist insert FirstRequest;
 if FirstRequest.tendency = down
  downrequestlist insert FirstRequest;
 tendency = FirstRequest.tendency;
 
 insert(data){
  if list.empty == true{
  list.head = data;
  }
  else
   for (i== list.begin(), list.end(),i++){
    if i.data< data < i->next.data
     insert data here;
   } 
 }
 
 
 while tendency == up{
      for (i = uprequestlist.begin(),uprequestlist.end(),i++){
        listOfStop.insert i.theFloorRequestAt;
        listOfStop.insert i.theFloorRequestTo;
        }
      if OutsideButton.tendency == up && currentfloor<OutsideButton.theFloorRequestAt{
        listOfStop insert OutsideButton.theFloorRequestAt;
        listOfStop insert OutsideButton.theFloorRequestTo;
        }
      if OutsideButton.tendency == up && OutsideButton.theFloorRequestAt<currentfloor{
         uprequestlist insert OutsideButton;
         }
      if OutsideButton.tendency == down && OutsideButton.theFloorRequestAt{
         downrequestlist insert OutsideButton;
      }
    if currentfloor reach the element in listOfStop{
    listOfStop.delete iterater
    }
    if listOfStop.empty == true{
    tendency = down
    }
    
 while tendency == down{
    for (i = downrequestlist.begin(),downrequestlist.end(),i++)
     listOfStop.insert i.theFloorRequestAt;
     listOfStop.insert i.theFloorRequestTo;
    if OutsideButton.tendency == down && currentfloor>OutsideButton.theFloorRequestAt{
        listOfStop insert OutsideButton.theFloorRequestAt;
        listOfStop insert OutsideButton.theFloorRequestTo;
        }
      if OutsideButton.tendency == down && OutsideButton.theFloorRequestAt>currentfloor{
         downrequestlist insert OutsideButton;
         }
      if OutsideButton.tendency == up && OutsideButton.theFloorRequestAt{
         uprequestlist insert OutsideButton;
      }
    if currentfloor reach the element in listOfStop{
    listOfStop.delete iterater
    }
    if listOfStop.empty == true{
    tendency = up
    } 
 }
 #end here
/////////////////////////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////////////////////////////
#algorithm by leo
#For multi-elevator
struct OutSideRequest{
 tendency (up or down)
 theFloorRequestAt;
 };
 
 struct Elevator{
 tendency (up or down or nonusing)
 current_floor;
 List listOfStop;
 List ListOfInsideRequest;
 };
 
 vector<Elevator> upElevator;
 vector<Elevator> downElevator;
 vector<Elevator> nonusingElevator;
 List uprequestlist;
 List downrequestlist;

 
 insert(data){
  if list.empty == true{
  list.head = data;
  }
  else
   for (i== list.begin(), list.end(),i++){
    if i.data< data < i->next.data
     insert data here;
   } 
 }
 
 for(i=upElevator.begin();upElevator.end();i++){
   if(i.listOfInsideRequest.empty()!=true){
      for(n=listOfInsideRequest.begin();listOfInsideRequest.end();n++){
         if(n>=current_floor){
          i.ListOfStop.insert(n);
          i.ListOfInsideRequest.remove(n);
         }
      }
   }
 }
 
  for(i=downElevator.begin();downElevator.end();i++){
   if(i.listOfInsideRequest.empty()!=true){
      for(n=listOfInsideRequest.begin();listOfInsideRequest.end();n++){
         if(n<=current_floor){
          i.ListOfStop.insert(n);
          i.ListOfInsideRequest.remove(n);
         }
      }
   }
 }
 
 
 for(i=upElevator.begin();upElebator.end();i++){
   if(i.listOfStop.empty()==true){
     if(i.listOfRequest.empty()==true){
       nonusingElevator.pushback(i);
       upElevator.remove(i);
       }
      else if(i.listOfRequest.empty()==false){
       for(n=i.listOfRequest.begin();i.listOfRequest.end();n++){
        i.listOfStop.insert(n);
       }
       downElevator.pushback(i);
       upElevator.remove(i);
      }
 }
 
 for(i=downElevator.begin();downElebator.end();i++){
   if(i.listOfStop.empty()==true){
     if(i.listOfRequest.empty()==true){
       nonusingElevator.pushback(i);
       downElevator.remove(i);
       }
      else if(i.listOfRequest.empty()==false){
       for(n=i.listOfRequest.begin();i.listOfRequest.end();n++){
        i.listOfStop.insert(n);
       }
       upElevator.pushback(i);
       downElevator.remove(i);
      }
 }
 
 if(OutSideRequest.tendency = up){
  if(nonusingElevator.empty()!=true){
    for(i=nonusingElevator.begin();nonusingElevator.end();i++){
     find the closet nonusingElevator C for request;
     upElevator.pushback(C);
    }
  }
 uprequestlist.insert(OutSideRequest.theFloorRequestAt())
 }
 
 if(OutSideRequest.tendency = down){
   if(nonusingElevator.empty()!=true){
     for(i=nonusingElevator.begin();nonusingElevator.end();i++){
       find the closet nonusingElevator C for request;
       downElevator.pushback(C);
            }
      }
 downrequestlist.insert(OutSideRequest.theFloorRequestAt())
 }
 
 for(i=upElevator.begin(),upElevator.end(),++){
     if i.listOfStop.empty = true;
     nonusing Elevator.pushback(i);
     upElevator.remove(i);
 }
 for(i=downElevator.begin(),downElevator.end(),++){
     if i.listOfStop.empty = true;
     nonusing Elevator.pushback(i);
     downElevator.remove(i);
 }
 
 for (n=uprequestlist.begin(),uprequestlist.end(),n++){
   for(i=upElevator.begin(),upElevator.end(),i++){
    
    if i.current_floor == n.theFloorRequestAt{ //if one or more of upelevator current_floor is at Request.theFloorRequestAt
       uprequestlist.remove(n);
       for(upElevators rather than i)
         .listofStop.remove(i.current_floor);
    }
    else if i.current_floor<n.theFloorRequestAt{ //if one or more of upelevator is below where the RequestAt, 
       i.listOfStop.insert(n.theFloorRequestAt); // elevator insert the thefloorRequestAt into the listOfStop
       }
    }
    
    
 for (n=downrequestlist.begin(),downrequestlist.end(),n++){
   for(i=downElevator.begin(),downElevator.end(),i++){
    
    if i.current_floor == n.theFloorRequestAt{ //if one or more of upelevator current_floor is at Request.theFloorRequestAt
       downrequestlist.remove(n);
       for(downElevators rather than i)
         .listofStop.remove(i.current_floor);
    }
    else if i.current_floor>n.theFloorRequestAt{ //if one or more of upelevator is below where the RequestAt, 
       i.listOfStop.insert(n.theFloorRequestAt); // elevator insert the thefloorRequestAt into the listOfStop
       }
    }   
    
    
    #end here
/////////////////////////////////////////////////////////////////////////////////////////////////////         
return 0;



