A simple algorithm for handling requests: all requests users make are stored.
The elevator prioritizes the requests that are on the way where itâ€™s going, but also based on a first come first served principle.

Write a simulation function that calculates the waiting time for users.
 A user pushes either the up or down button to request the elevator.
 Once the elevator arrives, the user gets in and specifies his/her destination floor. 
 Meanwhile, other users outside or inside the elevator make requests as well.

1. How many types of data structure will we have and how will they be implemented.
2. What are we trying to do? (create a queue for elevator? How do we determine how the elevator moves?)
3. how many classes are we using? (Elevator class, passenger class?, queue class?, list?)

We need to create a UML and Diagram and do a Big-O of each functions.

/////////////////////////////////////////////////////////////////////////////////////////////////
#algorithm by leo
#For single elevator (Havent finished yet)

 insert(data){ //only for uprequestlist and ListOfStop when tendency is up
  insert data in from small to large order
 }
 insert(data){ //only for downrequestlist
  insert data in from large to small order and ListOfStop when tendency is down
 }
struct Request{
 tendency (up or down)
 theFloorRequestAt
 }
 
 struct Elevator{
 tendency (up or down or stop)
 current_floor;
 List listOfStop;
 List ListOfInsideRequest;
 };

 List uprequestlist;
 List downrequestlist;

 Request FirstRequest;
 
 if Request.tendency = up
  uprequestlist.insert(FirstRequest);
 if Request.tendency = down
  downrequestlist.insert(FirstRequest);
 

 if Elevator.tendency == up{
  for (i=ListOfInsideRequest.begin();ListOfInsideRequest.end();i++){
     if(i.theFloorRequestTo >= current_floor){
       Elevator.listOfStop.insert(i.theFloorRequestTo);
     else
       downrequestlist.insert(i.theFloorRequestTo);
     }
  }
  for (n=uprequestlist.begin(),uprequestlist.end(),n++){    
    if (Elevator.current_floor == n.theFloorRequestAt){ //if one or more of upelevator current_floor is at Request.theFloorRequestAt
       uprequestlist.remove(n);
       Elevator.listofStop.remove(i.current_floor);
    }
    else if i.current_floor<n.theFloorRequestAt{ //if one or more of upelevator is below where the RequestAt, 
       i.listOfStop.insert(n.theFloorRequestAt); // elevator insert the thefloorRequestAt into the listOfStop
       }
  }
  if (Elevator.listOfStop.empty){
     if(uprequestlist.empty()&&downrequestlist.empty()){
        Elevator.tendency = stop;
     }
     else if(downrequestlist.tail>current_floor)
     Elevator.tendency = up;
     }
     else
     Elevator.tendency = down;
  }

 if Elevator.tendency == down{
  for (i=ListOfInsideRequest.begin();ListOfInsideRequest.end();i++){
     if(i.theFloorRequestTo <= current_floor){
       Elevator.listOfStop.insert(i.theFloorRequestTo);
     else
       uprequestlist.insert(i.theFloorRequestTo);
     }
  }
  for (n=downrequestlist.begin(),downrequestlist.end(),n++){    
    if (Elevator.current_floor == n.theFloorRequestAt){ //if one or more of upelevator current_floor is at Request.theFloorRequestAt
       downrequestlist.remove(n);
       Elevator.listofStop.remove(i.current_floor);
    }
    else if i.current_floor>n.theFloorRequestAt{ //if one or more of upelevator is below where the RequestAt, 
       i.listOfStop.insert(n.theFloorRequestAt); // elevator insert the thefloorRequestAt into the listOfStop
       }
  }
   if (Elevator.listOfStop.empty){
     if(uprequestlist.empty()&&downrequestlist.empty()){
        Elevator.tendency = stop;
     }
     else if(uprequestlist.head<current_floor)
     Elevator.tendency = down;
     }
     else
     Elevator.tendency = up;
  }
 #end here
/////////////////////////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////////////////////////////
#algorithm by leo
#For multi-elevator
struct OutSideRequest{
 tendency (up or down)
 theFloorRequestAt;
 };
 
 struct Elevator{
 tendency (up or down or nonusing)
 current_floor;
 List listOfStop;
 List ListOfInsideRequest;
 };
 
 vector<Elevator> upElevator;
 vector<Elevator> downElevator;
 vector<Elevator> nonusingElevator;
 List uprequestlist;
 List downrequestlist;

 
 insert(data){
  if list.empty == true{
  list.head = data;
  }
  else
   for (i== list.begin(), list.end(),i++){
    if i.data< data < i->next.data
     insert data here;
   } 
 }
 
 if(OutSideRequest.tendency = up){
 uprequestlist.insert(OutSideRequest.theFloorRequestAt())
 }
 
 if(OutSideRequest.tendency = down){
 downrequestlist.insert(OutSideRequest.theFloorRequestAt())
 }
 
 for(i=upElevator.begin();upElevator.end();i++){
   if(i.listOfInsideRequest.empty()!=true){
      for(n=listOfInsideRequest.begin();listOfInsideRequest.end();n++){
         if(n>=current_floor){
          i.ListOfStop.insert(n);
          i.ListOfInsideRequest.remove(n);
         }
      }
   }
 }
 
  for(i=downElevator.begin();downElevator.end();i++){
   if(i.listOfInsideRequest.empty()!=true){
      for(n=listOfInsideRequest.begin();listOfInsideRequest.end();n++){
         if(n<=current_floor){
          i.ListOfStop.insert(n);
          i.ListOfInsideRequest.remove(n);
         }
      }
   }
 }
 
 
 for(i=upElevator.begin();upElebator.end();i++){
   if(i.listOfStop.empty()==true){
     if(i.listOfInsideRequest.empty()==true){
       nonusingElevator.pushback(i);
       upElevator.remove(i);
       }
      else if(i.listOfInsideRequest.empty()==false){
       for(n=i.listOfInsideRequest.begin();i.listOfRequest.end();n++){
        i.listOfStop.insert(n);
       }
       downElevator.pushback(i);
       upElevator.remove(i);
      }
 }
 
 for(i=downElevator.begin();downElebator.end();i++){
   if(i.listOfStop.empty()==true){
     if(i.listOfInsideRequest.empty()==true){
       nonusingElevator.pushback(i);
       downElevator.remove(i);
       }
      else if(i.listOfInsideRequest.empty()==false){
       for(n=i.listOfInsideRequest.begin();i.listOfRequest.end();n++){
        i.listOfStop.insert(n);
       }
       upElevator.pushback(i);
       downElevator.remove(i);
      }
 }
 for(i=nonusingElevator.begin();nonusingElebator.end();i++){
   if(uprequestlist.empty!=true){
     if(uprequestlist.head<current_floor){
       downElevator.pushback(i);
       nonusingElevator.remove(i);
       }
     else if(uprequestlist.head>current_floor){
       upElevator.pushback(i);
       nonusingElevator.remove(i);
     }
   if(downrequestlist.empty!=true){
     if(downrequestlist.tail<current_floor){
       downElevator.pushback(i);
       nonusingElevator.remove(i);
       }
     else if(downrequestlist.tail>current_floor){
       upElevator.pushback(i);
       nonusingElevator.remove(i);
     }
 }

 
 for(i=upElevator.begin(),upElevator.end(),++){
     if i.listOfStop.empty = true;
     nonusing Elevator.pushback(i);
     upElevator.remove(i);
 }
 for(i=downElevator.begin(),downElevator.end(),++){
     if i.listOfStop.empty = true;
     nonusing Elevator.pushback(i);
     downElevator.remove(i);
 }
 
 for (n=uprequestlist.begin(),uprequestlist.end(),n++){
   for(i=upElevator.begin(),upElevator.end(),i++){
    
    if i.current_floor == n.theFloorRequestAt{ //if one or more of upelevator current_floor is at Request.theFloorRequestAt
       uprequestlist.remove(n);
       for(upElevators rather than i)
         .listofStop.remove(i.current_floor);
    }
    else if i.current_floor<n.theFloorRequestAt{ //if one or more of upelevator is below where the RequestAt, 
       i.listOfStop.insert(n.theFloorRequestAt); // elevator insert the thefloorRequestAt into the listOfStop
       }
    }
    
    
 for (n=downrequestlist.begin(),downrequestlist.end(),n++){
   for(i=downElevator.begin(),downElevator.end(),i++){
    
    if i.current_floor == n.theFloorRequestAt{ //if one or more of upelevator current_floor is at Request.theFloorRequestAt
       downrequestlist.remove(n);
       for(downElevators rather than i)
         .listofStop.remove(i.current_floor);
    }
    else if i.current_floor>n.theFloorRequestAt{ //if one or more of upelevator is below where the RequestAt, 
       i.listOfStop.insert(n.theFloorRequestAt); // elevator insert the thefloorRequestAt into the listOfStop
       }
    }   
    
    
    #end here
/////////////////////////////////////////////////////////////////////////////////////////////////////         
return 0;



